"use strict";(self.webpackChunkrx_angular=self.webpackChunkrx_angular||[]).push([[7944],{2466:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>u});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),s=["components"],i={sidebar_label:"RxState",sidebar_position:1,title:"RxState"},o=void 0,p={unversionedId:"state/api/rx-state",id:"state/api/rx-state",title:"RxState",description:"Overview",source:"@site/docs/state/api/rx-state.md",sourceDirName:"state/api",slug:"/state/api/rx-state",permalink:"/docs/state/api/rx-state",draft:!1,editUrl:"https://github.com/rx-angular/rx-angular/edit/main/docs/state/api/rx-state.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_label:"RxState",sidebar_position:1,title:"RxState"},sidebar:"docs",previous:{title:"Setup",permalink:"/docs/state/getting-started/setup"},next:{title:"RxJS Operators",permalink:"/docs/category/rxjs-operators"}},c={},u=[{value:"Overview",id:"overview",level:2},{value:"Signature",id:"signature",level:2},{value:"$ (state observable)",id:"-state-observable",level:2},{value:"typeof: Observable&lt;T&gt;",id:"typeof-observablet",level:5},{value:"connect",id:"connect",level:2},{value:"Signature",id:"signature-1",level:3},{value:"Signature",id:"signature-2",level:3},{value:"Signature",id:"signature-3",level:3},{value:"set",id:"set",level:2},{value:"Signature",id:"signature-4",level:3},{value:"Signature",id:"signature-5",level:3},{value:"select",id:"select",level:2},{value:"Signature",id:"signature-6",level:3},{value:"Signature",id:"signature-7",level:3},{value:"Signature",id:"signature-8",level:3},{value:"Signature",id:"signature-9",level:3},{value:"Signature",id:"signature-10",level:3},{value:"get",id:"get",level:2},{value:"Signature",id:"signature-11",level:3},{value:"Signature",id:"signature-12",level:3},{value:"hold",id:"hold",level:2},{value:"Signature",id:"signature-13",level:3},{value:"setAccumulator",id:"setaccumulator",level:2},{value:"Signature",id:"signature-14",level:3}],d={toc:u};function m(e){var t=e.components,i=(0,r.Z)(e,s);return(0,l.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"overview"},"Overview"),(0,l.kt)("p",null,"RxState is a light-weight reactive state management service for managing local state in angular."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"Component({\n  selector: 'app-stateful',\n  template: `<div>{{ state$ | async | json }}</div>`,\n  providers: [RxState],\n});\nexport class StatefulComponent {\n  readonly state$ = this.state.select();\n\n  constructor(private state: RxState<{ foo: string }>) {}\n}\n")),(0,l.kt)("h2",{id:"signature"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"class RxState<T extends object> implements OnDestroy, Subscribable<T> {\n  readonly $: Observable<T> = this.accumulator.signal$;\n\n  connect(inputOrSlice$: Observable<Partial<T> | V>, projectFn?: ProjectStateReducer<T, V>) => void;\n  connect(key: K, slice$: Observable<T[K]>) => void;\n  connect(key: K, input$: Observable<V>, projectSliceFn: ProjectValueReducer<T, K, V>) => void;\n\n  set(stateOrProjectState: Partial<T> | ProjectStateFn<T>) => void;\n  set(key: K, projectSlice: ProjectValueFn<T, K>) => void;\n\n  select(op: OperatorFunction<T, A>) => Observable<A>;\n  select(k1: K1) => Observable<T[K1]>;\n  select(k: K, fn: (val: T[K]) => V): Observable<V>;\n  select(keys: K[], fn: (slice: PickSlice<T, K>) => V, keyCompareMap?: KeyCompareMap<Pick<T, K>>): Observable<V>;\n  select() => Observable<T>;\n\n  get() => T;\n  get(k1: K1) => Partial<T>;\n\n  hold(obsOrObsWithSideEffect: Observable<S>, sideEffectFn?: (arg: S) => void) => void;\n\n  setAccumulator(accumulatorFn: AccumulationFn) => void;\n}\n")),(0,l.kt)("p",null,(0,l.kt)("img",{src:a(5442).Z,width:"960",height:"285"})),(0,l.kt)("p",null,(0,l.kt)("img",{src:a(4854).Z,width:"960",height:"285"})),(0,l.kt)("h2",{id:"-state-observable"},"$ (state observable)"),(0,l.kt)("h5",{id:"typeof-observablet"},"typeof: Observable","<","T",">"),(0,l.kt)("p",null,"The unmodified state exposed as ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<T>"),". It is not shared, distinct or gets replayed.\nUse the ",(0,l.kt)("inlineCode",{parentName:"p"},"$")," property if you want to read the state without having applied ",(0,l.kt)("a",{parentName:"p",href:"/docs/state/api/rxjs-operators/stateful"},"stateful")," to it."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"connect"},"connect"),(0,l.kt)("h3",{id:"signature-1"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"connect(inputOrSlice$: Observable<Partial<T> | V>, projectFn?: ProjectStateReducer<T, V>): void\n")),(0,l.kt)("p",null,"Connect an ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<Partial<T>>")," to the state ",(0,l.kt)("inlineCode",{parentName:"p"},"T"),".\nAny change emitted by the source will get merged into the state.\nSubscription handling is done automatically."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const sliceToAdd$ = interval(250).pipe(mapTo({\n  bar: 5,\n  foo: 'foo'\n});\nstate.connect(sliceToAdd$);\n// every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$\n\n// Additionally you can provide a `projectionFunction` to access the current state object and do custom mappings.\n\nconst sliceToAdd$ = interval(250).pipe(mapTo({\n  bar: 5,\n  foo: 'foo'\n});\nstate.connect(sliceToAdd$, (state, slice) => state.bar += slice.bar);\n// every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$. Bar will increase by\n// 5 due to the projectionFunction\n")),(0,l.kt)("h3",{id:"signature-2"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"connect(key: K, slice$: Observable<T[K]>): void\n")),(0,l.kt)("p",null,"Connect an ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<T[K]>")," source to a specific property ",(0,l.kt)("inlineCode",{parentName:"p"},"K")," in the state ",(0,l.kt)("inlineCode",{parentName:"p"},"T"),". Any emitted change will update\nthis\nspecific property in the state.\nSubscription handling is done automatically."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const myTimer$ = interval(250);\nstate.connect('timer', myTimer$);\n// every 250ms the property timer will get updated\n")),(0,l.kt)("h3",{id:"signature-3"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"connect(key: K, slice$: Observable<V>, projectSliceFn: ProjectValueReducer<T, K, V>): void\n")),(0,l.kt)("p",null,"Connect an ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<V>")," source to a specific property in the state. Additionally you can provide a\n",(0,l.kt)("inlineCode",{parentName:"p"},"projectionFunction")," to access the current state object on every emission of your connected ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable"),".\nAny change emitted by the source will get merged into the state.\nSubscription handling is done automatically."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const myTimer$ = interval(250);\nstate.connect(\n  'timer',\n  myTimer$,\n  (state, timerChange) => (state.timer += timerChange)\n);\n// every 250ms the property timer will get updated\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"set"},"set"),(0,l.kt)("h3",{id:"signature-4"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"set(stateOrProjectState: Partial<T> | ProjectStateFn<T>): void\n")),(0,l.kt)("p",null,"Manipulate one or many properties of the state by providing a ",(0,l.kt)("inlineCode",{parentName:"p"},"Partial<T>")," state or a ",(0,l.kt)("inlineCode",{parentName:"p"},"ProjectionFunction<T>"),"."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"// Update one or many properties of the state by providing a `Partial<T>`\n\nconst partialState = {\n  foo: 'bar',\n  bar: 5,\n};\nstate.set(partialState);\n\n// Update one or many properties of the state by providing a `ProjectionFunction<T>`\n\nconst reduceFn = (oldState) => ({\n  bar: oldState.bar + 5,\n});\nstate.set(reduceFn);\n")),(0,l.kt)("h3",{id:"signature-5"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"set(key: K, projectSlice: ProjectValueFn<T, K>): void\n")),(0,l.kt)("p",null,"Manipulate a single property of the state by the property name and a ",(0,l.kt)("inlineCode",{parentName:"p"},"ProjectionFunction<T>"),"."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const reduceFn = (oldState) => oldState.bar + 5;\nstate.set('bar', reduceFn);\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"select"},"select"),(0,l.kt)("h3",{id:"signature-6"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"select(): Observable<T>\n")),(0,l.kt)("p",null,"Returns the state as cached and distinct ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<T>"),". This way you don't have to think about ",(0,l.kt)("strong",{parentName:"p"},"late\nsubscribers"),",\n",(0,l.kt)("strong",{parentName:"p"},"multiple subscribers")," or ",(0,l.kt)("strong",{parentName:"p"},"multiple emissions")," of the same value"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const state$ = state.select();\nstate$.subscribe((state) => doStuff(state));\n")),(0,l.kt)("h3",{id:"signature-7"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"select(op: OperatorFunction<T, A>): Observable<A>\n")),(0,l.kt)("p",null,"Returns the state as cached and distinct ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<A>"),". Accepts arbitrary\n",(0,l.kt)("a",{parentName:"p",href:"https://rxjs-dev.firebaseapp.com/guide/operators"},"rxjs operators")," to enrich the selection with reactive composition."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const profilePicture$ = state.select(\n  pluck('profilePicture'),\n  switchMap((profilePicture) => mapImageAsync(profilePicture))\n);\n")),(0,l.kt)("h3",{id:"signature-8"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"select(k1: K1): Observable<T[K1]>\n")),(0,l.kt)("p",null,"Access a single property of the state by providing keys.\nReturns a single property of the state as cached and distinct ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<T[K1]>"),"."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"// Access a single property\n\nconst bar$ = state.select('bar');\n\n// Access a nested property\n\nconst foo$ = state.select('bar', 'foo');\n")),(0,l.kt)("h3",{id:"signature-9"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"select(k: K, fn: (val: T[K]) => V): Observable<V>;\n")),(0,l.kt)("p",null,"Transform a single property of the state by providing a key and map function.\nReturns result of applying function to state property as cached and distinct ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<V>"),"."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"// Project state based on single property\nconst foo$ = state.select('bar', (bar) => `bar equals ${bar}`);\n")),(0,l.kt)("h3",{id:"signature-10"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"select(keys: K[], fn: (slice: PickSlice<T, K>) => V, keyCompareMap?: KeyCompareMap<Pick<T, K>>): Observable<V>;\n")),(0,l.kt)("p",null,"Transform a slice of the state by providing keys and map function.\nReturns result of applying function to state slice as cached and distinct ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<V>"),"."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"// Project state slice\nconst text$ = state.select(\n  ['query', 'results'],\n  ({ query, results }) => `${results.length} results found for \"${query}\"`\n);\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"get"},"get"),(0,l.kt)("h3",{id:"signature-11"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"get(): T\n")),(0,l.kt)("p",null,"Read from the state in imperative manner. Returns the state object in its current state."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const { disabled } = state.get();\nif (!disabled) {\n  doStuff();\n}\n")),(0,l.kt)("h3",{id:"signature-12"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"get(k1: K1): Partial<T>\n")),(0,l.kt)("p",null,"Read from the state in an imperative manner by providing keys as parameters to reach deeply nested values.\nReturns the part of state object."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"interface State {\n  bar: { foo: `test` };\n  baz: true;\n}\n\n// Access a single property\n\nconst bar = state.get('bar');\n\n// Access a nested property\n\nconst foo = state.get('bar', 'foo');\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"hold"},"hold"),(0,l.kt)("h3",{id:"signature-13"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"  hold(obsOrObsWithSideEffect: Observable<S>, sideEffectFn?: (arg: S) => void): void\n")),(0,l.kt)("p",null,"Manages side-effects of your state. Provide an ",(0,l.kt)("inlineCode",{parentName:"p"},"Observable<any>")," ",(0,l.kt)("strong",{parentName:"p"},"side-effect")," and an optional\n",(0,l.kt)("inlineCode",{parentName:"p"},"sideEffectFunction"),".\nSubscription handling is done automatically."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"// Directly pass an observable side-effect\nconst localStorageEffect$ = changes$.pipe(\n  tap((changes) => storeChanges(changes))\n);\nstate.hold(localStorageEffect$);\n\n// Pass an additional `sideEffectFunction`\n\nconst localStorageEffectFn = (changes) => storeChanges(changes);\nstate.hold(changes$, localStorageEffectFn);\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"setaccumulator"},"setAccumulator"),(0,l.kt)("h3",{id:"signature-14"},"Signature"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"setAccumulator(accumulatorFn: AccumulationFn) => void\n")),(0,l.kt)("p",null,"Allows to customize state accumulation function.\nThis can be helpful to implement deep updates and tackle other immutability problems in a custom way."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const myAccumulator = (state: MyState, slice: Partial<MyState>) => ({\n  ...state,\n  ...slice,\n});\n\nthis.state.setAccumulator(myAccumulator);\n")))}m.isMDXComponent=!0},3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(a),m=r,g=d["".concat(o,".").concat(m)]||d[m]||u[m]||l;return a?n.createElement(g,s(s({ref:t},c),{},{components:a})):n.createElement(g,s({ref:t},c))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,s=new Array(l);s[0]=d;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<l;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4854:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/api-reveal-2299750fc2aedc2b2c3a2f2074aa0574.jpg"},5442:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/api-schema-e8987e00c842fe71046b15de7019ed59.jpg"}}]);