"use strict";(self.webpackChunkrx_angular=self.webpackChunkrx_angular||[]).push([[3707],{9201:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>s,metadata:()=>p,toc:()=>d});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],s={sidebar_position:2,sidebar_label:"Work with HostBindings",title:"HostBindings"},l="HostBindings",p={unversionedId:"state/recipes/work-with-hostbindings",id:"state/recipes/work-with-hostbindings",title:"HostBindings",description:"Some examples how to reactively handle basic HostBindings with @rx-angular/state RxState.",source:"@site/docs/state/recipes/work-with-hostbindings.md",sourceDirName:"state/recipes",slug:"/state/recipes/work-with-hostbindings",permalink:"/docs/state/recipes/work-with-hostbindings",draft:!1,editUrl:"https://github.com/rx-angular/rx-angular/edit/main/docs/state/recipes/work-with-hostbindings.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Work with HostBindings",title:"HostBindings"},sidebar:"docs",previous:{title:"Load data on route change",permalink:"/docs/state/recipes/load-data-on-route-change"},next:{title:"Use RxState as Global State",permalink:"/docs/state/recipes/use-rxstate-as-global-state"}},c={},d=[{value:"Be aware of changeDetection - HostBindings are not reactive",id:"be-aware-of-changedetection---hostbindings-are-not-reactive",level:2},{value:"Call ChangeDetection manually",id:"call-changedetection-manually",level:3},{value:"Let the template handle changeDetection",id:"let-the-template-handle-changedetection",level:3},{value:"Render on your own",id:"render-on-your-own",level:2}],u={toc:d};function g(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"hostbindings"},"HostBindings"),(0,o.kt)("p",null,"Some examples how to reactively handle basic ",(0,o.kt)("a",{parentName:"p",href:"https://angular.io/api/core/HostBinding"},(0,o.kt)("inlineCode",{parentName:"a"},"HostBindings"))," with ",(0,o.kt)("inlineCode",{parentName:"p"},"@rx-angular/state")," ",(0,o.kt)("inlineCode",{parentName:"p"},"RxState"),"."),(0,o.kt)("p",null,"Sadly ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings")," are not able to bind to ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable")," sources out of the box. So we have to come up with custom solutions\nin order to have fully reactive components."),(0,o.kt)("p",null,"In the following examples we will use the ",(0,o.kt)("inlineCode",{parentName:"p"},"rxLet")," directive or the ",(0,o.kt)("inlineCode",{parentName:"p"},"push")," pipe as replacements for angulars ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," pipe.\n",(0,o.kt)("inlineCode",{parentName:"p"},"rxLet")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"push")," belong to the not yet released ",(0,o.kt)("inlineCode",{parentName:"p"},"@rx-angular/template")," package."),(0,o.kt)("p",null,"Furthermore we want to express that we will come up with a more convenient solution facing this problem. This can be seen as WIP and\nshould not be the longterm solution to handle ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings")," in a fully reactive way."),(0,o.kt)("p",null,"Imagine you have the following state which you want to bind to properties of your host element."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ComponentState {\n  visible: boolean;\n  top: number;\n  maxHeight: number;\n}\n")),(0,o.kt)("h2",{id:"be-aware-of-changedetection---hostbindings-are-not-reactive"},"Be aware of changeDetection - HostBindings are not reactive"),(0,o.kt)("p",null,"In this setup we assign our ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"get()")," method of our state."),(0,o.kt)("p",null,"As stated in the title, we have to be aware changeDetection. On every changeDetection cycle, angular will re-evaluate\nall ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings"),". If our component doesn't get flagged as dirty, our ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings")," won't get updated. So we have to make\nsure that state changes that are related to the ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings")," value are actually triggering a re-render."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  providers: [RxState],\n})\nexport class RxComponent {\n  // Modifying the class\n  @HostBinding('[class.is-hidden]') get isHidden() {\n    return !this.state.get().visible;\n  }\n  // Modifying styles\n  @HostBinding('[style.marginTop]') get marginTop() {\n    return `${this.state.get().top}px`;\n  }\n  // Modifying styles\n  @HostBinding('[style.maxHeight]') get maxHeight() {\n    return `${this.state.get().maxHeight}px`;\n  }\n\n  constructor(private state: RxState<ComponentState>) {}\n}\n")),(0,o.kt)("p",null,"With this setup in place we have two options to get things done."),(0,o.kt)("h3",{id:"call-changedetection-manually"},"Call ChangeDetection manually"),(0,o.kt)("p",null,"Since rendering is a side-effect, we could utilize the ",(0,o.kt)("inlineCode",{parentName:"p"},"hold")," method and register\na function which handles change detection for us."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  providers: [RxState],\n})\nexport class RxComponent {\n  // Modifying the class\n  @HostBinding('[class.is-hidden]') get isHidden() {\n    return !this.state.get().visible;\n  }\n  // Modifying styles\n  @HostBinding('[style.marginTop]') get marginTop() {\n    return `${this.state.get().top}px`;\n  }\n  // Modifying styles\n  @HostBinding('[style.maxHeight]') get maxHeight() {\n    return `${this.state.get().maxHeight}px`;\n  }\n\n  constructor(\n    private state: RxState<ComponentState>,\n    private cdRef: ChangeDetectorRef\n  ) {\n    state.hold(state.select(), () => this.cdRef.markForCheck());\n  }\n}\n")),(0,o.kt)("p",null,"By calling ",(0,o.kt)("inlineCode",{parentName:"p"},"ChangeDetectorRef#markForCheck")," after every state change, we flag our component dirty when needed and let angulars\n",(0,o.kt)("inlineCode",{parentName:"p"},"ChangeDetection")," do it's magic for us."),(0,o.kt)("h3",{id:"let-the-template-handle-changedetection"},"Let the template handle changeDetection"),(0,o.kt)("p",null,"If you happen to need your variables not only for your ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings")," but aswell in the view, we could easily let\nour viewHelpers take care of detecting changes. Just make sure all of your variables needed for the ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings")," are bound\nto the view correctly."),(0,o.kt)("p",null,"Inside the component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  readonly viewState$ = this.state.select();\n")),(0,o.kt)("p",null,"Inside the template:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<ng-container *rxLet="viewState$; let s">\n  <span *ngIf="s.visible">I am a visible span</span>\n</ng-container>\n')),(0,o.kt)("p",null,"In this scenario, the ",(0,o.kt)("inlineCode",{parentName:"p"},"rxLet")," directive will flag your component as dirty every time a new state arrives. By assigning the\nwhole state object as to your ",(0,o.kt)("inlineCode",{parentName:"p"},"viewModel$"),", any change will result in a re-rendering, thus updating your ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings"),"."),(0,o.kt)("h2",{id:"render-on-your-own"},"Render on your own"),(0,o.kt)("p",null,"With this setup you can opt-out of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ChangeDetection")," of angular and manage ",(0,o.kt)("inlineCode",{parentName:"p"},"HostBindings")," completely on your own.\nThis approach even works when calling ",(0,o.kt)("inlineCode",{parentName:"p"},"ChangeDetectorRef#detach")," for your component.\nWe will utilize the ",(0,o.kt)("inlineCode",{parentName:"p"},"ElementRef")," itself for this purpose and manipulate the DOM on our own."),(0,o.kt)("p",null,"Feel free to use angulars ",(0,o.kt)("inlineCode",{parentName:"p"},"Renderer2")," if you want an abstraction layer, should work the exact same way."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  providers: [RxState],\n})\nexport class RxComponent {\n  constructor(\n    private state: RxState<ComponentState>,\n    private elementRef: ElementRef<HTMLElement>,\n    private cdRef: ChangeDetectorRef\n  ) {\n    // optional: cdRef.detach();\n    this.state.hold(this.state.select(), ({ visible, top, maxHeight }) => {\n      const { nativeElement } = elementRef;\n      nativeElement.style.marginTop = `${top ? top : 0}px`;\n      nativeElement.style.maxHeight = `${maxHeight ? maxHeight : 100}px`;\n      // by using this, we could assign more classes\n      const classList: { [cls: string]: boolean } = {\n        'is-hidden': !visible,\n      };\n      Object.keys(classList).forEach((cls) => {\n        classList[cls]\n          ? nativeElement.classList.add(cls)\n          : nativeElement.classList.remove(cls);\n      });\n    });\n  }\n}\n")))}g.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),g=i,h=u["".concat(l,".").concat(g)]||u[g]||d[g]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);