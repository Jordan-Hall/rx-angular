"use strict";(self.webpackChunkrx_angular=self.webpackChunkrx_angular||[]).push([[9250],{8282:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>p,toc:()=>d});var a=n(7462),i=n(3366),s=(n(7294),n(3905)),r=["components"],l={title:"Migrating to RxState"},o="Migrating to RxState",p={unversionedId:"state/tutorials/migrating-to-rxstate",id:"state/tutorials/migrating-to-rxstate",title:"Migrating to RxState",description:"Let's take a look at a simple checklist app, see how it can be implemented in an imperative way, and after that, we will iterate over it and add some reactiveness. We skip any additional logic such as routing, error handling etc., in these examples.",source:"@site/docs/state/tutorials/migrating-to-rxstate.md",sourceDirName:"state/tutorials",slug:"/state/tutorials/migrating-to-rxstate",permalink:"/docs/state/tutorials/migrating-to-rxstate",draft:!1,editUrl:"https://github.com/rx-angular/rx-angular/edit/main/docs/state/tutorials/migrating-to-rxstate.md",tags:[],version:"current",frontMatter:{title:"Migrating to RxState"},sidebar:"docs",previous:{title:"Increment a Value",permalink:"/docs/state/tutorials/increment-a-value"},next:{title:"Passing observables directly",permalink:"/docs/state/tutorials/passing-observables-directly"}},c={},d=[{value:"Initial solution",id:"initial-solution",level:2},{value:"Step 1. Basic solution using BehaviorSubject",id:"step-1-basic-solution-using-behaviorsubject",level:2},{value:"Step 2. A bit more reactive component.",id:"step-2-a-bit-more-reactive-component",level:2},{value:"Step 3. Fully reactive component.",id:"step-3-fully-reactive-component",level:2}],u={toc:d};function m(e){var t=e.components,n=(0,i.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"migrating-to-rxstate"},"Migrating to RxState"),(0,s.kt)("p",null,"Let's take a look at a simple checklist app, see how it can be implemented in an imperative way, and after that, we will iterate over it and add some reactiveness. We skip any additional logic such as routing, error handling etc., in these examples."),(0,s.kt)("h2",{id:"initial-solution"},"Initial solution"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Interfaces")),(0,s.kt)("p",null,"The checklist interface:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"interface Checklist {\n  id: string;\n  name: string;\n  tasks: Task[];\n}\n")),(0,s.kt)("p",null,"The task interface:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export interface Task {\n  id: string;\n  name: string;\n}\n")),(0,s.kt)("p",null,"List is a nested smart component."),(0,s.kt)("p",null,"The component code:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export class ChecklistComponent implements OnInit, OnDestroy {\n  @Input() id: string;\n\n  checklist: Checklist;\n\n  private destroy$ = new Subject();\n\n  constructor(private api: TodoApiService) {}\n\n  ngOnInit(): void {\n    this.api\n      .get(this.id)\n      .pipe(takeUntil(this.destroy$))\n      .subscribe((checklist) => {\n        this.checklist = checklist;\n      });\n  }\n\n  ngOnDestroy(): void {\n    this.destroy$.next();\n  }\n\n  answerTask(id: string): void {\n    this.api\n      .answerTask(id)\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(() => {\n        this.checklist.tasks = this.checklist.tasks.filter((t) => t.id !== id);\n      });\n  }\n}\n")),(0,s.kt)("p",null,"The template:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<section class="checklist">\n  <h1>\n    <span>{{ checklist.name }}</span>\n  </h1>\n  <div>\n    <article class="task" *ngFor="let task of checklist.tasks">\n      <h2>{{ task.name }}</h2>\n      <button class="answer-button" (click)="answerTask(task.id)">Done</button>\n    </article>\n  </div>\n</section>\n')),(0,s.kt)("h2",{id:"step-1-basic-solution-using-behaviorsubject"},"Step 1. Basic solution using BehaviorSubject"),(0,s.kt)("p",null,'The first pattern that many developers switching to reactive programming with Angular & RxJS will find is the so-called "Observable data service" (organization of state with ',(0,s.kt)("inlineCode",{parentName:"p"},"BehaviorSubject")," as data storage)."),(0,s.kt)("p",null,"This pattern is pretty flexible and can be applied to services and components. It can even serve as a lightweight alternative to NgRx, NGXS, Akita, and other state management solutions with some tuning."),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Another alternative can be ",(0,s.kt)("inlineCode",{parentName:"em"},"merge")," + ",(0,s.kt)("inlineCode",{parentName:"em"},"scan")," operators to combine multiple observables and accumulate their values into a single state observable.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Let's create a state class that abstracts our BehaviorSubject and some basic operations we can do with it.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"State class")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export class State<T = any> {\n  data$: Observable<T>;\n\n  private dataSource$: BehaviorSubject<T>;\n\n  constructor(initialData: T) {\n    this.dataSource$ = new BehaviorSubject(initialData);\n    this.data$ = this.dataSource$.asObservable();\n  }\n\n  get snapshot(): T {\n    return this.dataSource$.getValue();\n  }\n\n  select<K extends keyof T>(path: K): Observable<T[K]> {\n    return this.data$.pipe(\n      map((state) => state[path])\n      // some additional logic\n    );\n  }\n\n  patch(data: Partial<T>): void {\n    this.dataSource$.next({ ...this.snapshot, ...data });\n  }\n}\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Data initialization happens inside the ",(0,s.kt)("inlineCode",{parentName:"li"},"constructor"),". We are passing ",(0,s.kt)("inlineCode",{parentName:"li"},"initialData")," of type ",(0,s.kt)("inlineCode",{parentName:"li"},"T"),", and it is set to our ",(0,s.kt)("inlineCode",{parentName:"li"},"dataSource$"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get snapshot()")," returns the current value from the ",(0,s.kt)("inlineCode",{parentName:"li"},"dataSource$"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"select <K extends keyof T>(path: K): Observable<T[K]>")," accepts key of ",(0,s.kt)("inlineCode",{parentName:"li"},"T")," and returns value of type ",(0,s.kt)("inlineCode",{parentName:"li"},"T[K]")," from ",(0,s.kt)("inlineCode",{parentName:"li"},"data$")," as observable. Selection is done with ",(0,s.kt)("inlineCode",{parentName:"li"},"map")," operator but ",(0,s.kt)("inlineCode",{parentName:"li"},"pluck")," is also an option. We are skipping any additional filtering/sharing logic in this example."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"patch(data: Partial<T>)")," accepts data of ",(0,s.kt)("inlineCode",{parentName:"li"},"Partial<T>")," and updates the current value of ",(0,s.kt)("inlineCode",{parentName:"li"},"dataSource$"),".")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Now we can organize ",(0,s.kt)("inlineCode",{parentName:"strong"},"List")," component in a more reactive way:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export class ChecklistComponent implements OnInit, OnDestroy {\n  @Input() id: string;\n\n  state = new State<Checklist>({\n    id: null,\n    name: null,\n    tasks: null,\n  });\n\n  name$ = this.state.select('name');\n\n  tasks$ = this.state.select('tasks');\n\n  private destroy$ = new Subject();\n\n  constructor(private api: TodoApiService) {}\n\n  ngOnInit(): void {\n    this.api\n      .get(this.id)\n      .pipe(takeUntil(this.destroy$))\n      .subscribe((checklist) => this.state.patch(checklist));\n  }\n\n  ngOnDestroy(): void {\n    this.destroy$.next();\n  }\n\n  answerTask(id: string): void {\n    this.api\n      .answerTask(id)\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(() => {\n        const snapshot = this.state.snapshot;\n        this.state.patch({\n          tasks: snapshot.tasks.filter((t) => t.id !== id),\n        });\n      });\n  }\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"The template:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<section class="checklist">\n  <h1>{{ name$ | async }}</h1>\n  <div>\n    <article class="task" *ngFor="let task of (tasks$ | async)">\n      <h2>{{ task.name }}</h2>\n      <button class="answer-button" (click)="answerTask(task.id)">Done</button>\n    </article>\n  </div>\n</section>\n')),(0,s.kt)("p",null,"What happens here:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Component gets initialized. Constructor gets involved."),(0,s.kt)("li",{parentName:"ul"},"Checklist id passed to the component through ",(0,s.kt)("inlineCode",{parentName:"li"},"@Input id: string")),(0,s.kt)("li",{parentName:"ul"},"In ",(0,s.kt)("inlineCode",{parentName:"li"},"OnInit")," lifecycle hook, we are getting our checklist by calling ",(0,s.kt)("inlineCode",{parentName:"li"},"get(id)")," method from our API service, subscribe to results and updating our ",(0,s.kt)("inlineCode",{parentName:"li"},"state"),"."),(0,s.kt)("li",{parentName:"ul"},"After that ",(0,s.kt)("inlineCode",{parentName:"li"},"name$")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"tasks$")," getting data from state through ",(0,s.kt)("inlineCode",{parentName:"li"},"select()")," method. (let's assume we placed some filtering logic in the ",(0,s.kt)("inlineCode",{parentName:"li"},"select()")," method, so we haven't received initial empty values)."),(0,s.kt)("li",{parentName:"ul"},"Data is displayed in component template with ",(0,s.kt)("inlineCode",{parentName:"li"},"async")," pipe. ",(0,s.kt)("inlineCode",{parentName:"li"},"<h1>{{name$ | async}}</h1>")," and ",(0,s.kt)("inlineCode",{parentName:"li"},'<article class="task"*ngFor="let task of (tasks$ | async)">')),(0,s.kt)("li",{parentName:"ul"},"User clicks on the ",(0,s.kt)("inlineCode",{parentName:"li"},"answer-button"),". Method ",(0,s.kt)("inlineCode",{parentName:"li"},"answerTask(task.id)")," is called."),(0,s.kt)("li",{parentName:"ul"},"We subscribe to the ",(0,s.kt)("inlineCode",{parentName:"li"},"answerTask")," method from our API service. Our API returns only the status code. So what we can do is just remove this task from UI. For this, we need to get existing tasks in some way. We are using ",(0,s.kt)("inlineCode",{parentName:"li"},"this.state.snapshot")," for this purpose. We filter tasks to exclude answered task from an array and updating our state with ",(0,s.kt)("inlineCode",{parentName:"li"},"patch()")," method.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Looks reactive?")),(0,s.kt)("p",null,"The reading part is pretty reactive. With the ",(0,s.kt)("inlineCode",{parentName:"p"},"select()")," method, we observe changes of state fields ",(0,s.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"tasks")," and render them with an ",(0,s.kt)("inlineCode",{parentName:"p"},"async")," pipe. So Angular will manage subscription for us. That's pretty cool."),(0,s.kt)("p",null,"But there are some issues with this approach."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Solution is depending on lifecycle hooks of our component. We need to remember the order in which initialization happens ",(0,s.kt)("inlineCode",{parentName:"li"},"constructor")," -> ",(0,s.kt)("inlineCode",{parentName:"li"},"ngOnChanges")," (that's where input binding will be initialized) -> ",(0,s.kt)("inlineCode",{parentName:"li"},"ngOnInit")," -> .... -> ",(0,s.kt)("inlineCode",{parentName:"li"},"ngOnDestroy"),"."),(0,s.kt)("li",{parentName:"ul"},"Update (or write) part is still imperative. We need to call a method in our component, subscribe to some observable and inside subscription update our state with ",(0,s.kt)("inlineCode",{parentName:"li"},"patch()")," method. We are breaking the reactive flow."),(0,s.kt)("li",{parentName:"ul"},"We have multiple subscriptions in a pretty simple component. Subscription management should be done manually if we don't use external packages or create our solution.")),(0,s.kt)("h2",{id:"step-2-a-bit-more-reactive-component"},"Step 2. A bit more reactive component."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"First, let's try to get rid of ",(0,s.kt)("inlineCode",{parentName:"strong"},"OnInit")," lifecycle hook.")),(0,s.kt)("p",null,"We need some ",(0,s.kt)("strong",{parentName:"p"},"event")," for initialization. Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"Subject")," for this."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"init$ = new Subject<string>();\n")),(0,s.kt)("p",null,"Now we need a place from which we can ",(0,s.kt)("strong",{parentName:"p"},"trigger")," this event. ",(0,s.kt)("inlineCode",{parentName:"p"},"@Input id: string")," is where we get the checklist id that is needed for initialization. We are planning to remove ",(0,s.kt)("inlineCode",{parentName:"p"},"OnInit"),", so there is no need to introduce ",(0,s.kt)("inlineCode",{parentName:"p"},"OnChanges")," to our component. Let's make a setter!"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"@Input() set id(id: string) {\n  this.init$.next(id);\n}\n")),(0,s.kt)("p",null,"Also, we need to write a logic for getting our checklist from API and storing a response:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"initHandler$ = this.init$.pipe(\n  switchMap((id) =>\n    this.api.get(id).pipe(tap((checklist) => this.state.patch(checklist)))\n  )\n);\n")),(0,s.kt)("p",null,"So far, so good. Inside ",(0,s.kt)("inlineCode",{parentName:"p"},"switchMap"),", we are getting value passed to ",(0,s.kt)("inlineCode",{parentName:"p"},"init$")," and switching to our API call. We\nare going as reactive as possible here and don't want to have any logic inside subscription and placed it\ninside ",(0,s.kt)("inlineCode",{parentName:"p"},"tap"),"."),(0,s.kt)("p",null,"Nice. Now we can get rid of ",(0,s.kt)("inlineCode",{parentName:"p"},"OnInit")," and subscription inside of it."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Let's handle tasks answering in the same manner and get rid of ",(0,s.kt)("inlineCode",{parentName:"strong"},"answerTask()")," method.")),(0,s.kt)("p",null,"Event"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"answer$ = new Subject<string>();\n")),(0,s.kt)("p",null,"Trigger"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<button class="answer-button" (click)="answer$.next(task.id)">Done</button>\n')),(0,s.kt)("p",null,"Answering logic"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"answerHandler$ = this.answer$.pipe(\n  withLatestFrom(this.tasks$),\n  switchMap(([id, tasks]) =>\n    this.api\n      .answerTask(id)\n      .pipe(\n        tap(() => this.state.patch({ tasks: tasks.filter((t) => t.id !== id) }))\n      )\n  )\n);\n")),(0,s.kt)("p",null,"Here we introduce an additional operator called ",(0,s.kt)("inlineCode",{parentName:"p"},"withLatestFrom"),". This way we can get latest value from our ",(0,s.kt)("inlineCode",{parentName:"p"},"this.tasks$ = this.state.select('tasks')")," in more reactive manner. ",(0,s.kt)("inlineCode",{parentName:"p"},"switchMap")," will receive array of values. The first one will be ",(0,s.kt)("inlineCode",{parentName:"p"},"id")," from ",(0,s.kt)("inlineCode",{parentName:"p"},"answer$")," and the second one will be our tasks."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Now we need to subscribe.")),(0,s.kt)("p",null,"Good fit is ",(0,s.kt)("inlineCode",{parentName:"p"},"constructor()"),". Here we use ",(0,s.kt)("inlineCode",{parentName:"p"},"merge")," to combine 2 observables and subscribe only once.\nUnsubscribe will happen on component destruction as in the original example."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(private api: TodoApiService) {\n  merge(this.initHandler$, this.answerHandler$)\n    .pipe(takeUntil(this.destroy$))\n    .subscribe();\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"The full component code:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export class ChecklistComponent implements OnDestroy {\n  @Input() set id(id: string) {\n    this.init$.next(id);\n  }\n\n  state = new State<Checklist>({\n    id: null,\n    name: null,\n    tasks: null,\n  });\n\n  // READS\n  name$ = this.state.select('name');\n  tasks$ = this.state.select('tasks');\n\n  // EVENTS\n  init$ = new Subject<string>();\n  answer$ = new Subject<string>();\n\n  initHandler$ = this.init$.pipe(\n    switchMap((id) =>\n      this.api.get(id).pipe(tap((checklist) => this.state.patch(checklist)))\n    )\n  );\n\n  answerHandler$ = this.answer$.pipe(\n    withLatestFrom(this.tasks$),\n    switchMap(([id, tasks]) =>\n      this.api\n        .answerTask(id)\n        .pipe(\n          tap(() =>\n            this.state.patch({ tasks: tasks.filter((t) => t.id !== id) })\n          )\n        )\n    )\n  );\n\n  private destroy$ = new Subject();\n\n  constructor(private api: TodoApiService) {\n    merge(this.initHandler$, this.answerHandler$)\n      .pipe(takeUntil(this.destroy$))\n      .subscribe();\n  }\n\n  ngOnDestroy(): void {\n    this.destroy$.next();\n  }\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Summary:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Now we have a bit more code but component is more reactive."),(0,s.kt)("li",{parentName:"ul"},"Component initialization is not depending on the ",(0,s.kt)("inlineCode",{parentName:"li"},"OnInit")," lifecycle hook and will be a reaction to the ",(0,s.kt)("inlineCode",{parentName:"li"},"init$")," event."),(0,s.kt)("li",{parentName:"ul"},"We removed imperative ",(0,s.kt)("inlineCode",{parentName:"li"},"answerTask()")," method."),(0,s.kt)("li",{parentName:"ul"},"Now we have only one subscription to manage."),(0,s.kt)("li",{parentName:"ul"},"We dont have any code inside subscription.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"However:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"We still need to manage subscription."),(0,s.kt)("li",{parentName:"ul"},"State updates are side effects of our API calls. We are using ",(0,s.kt)("inlineCode",{parentName:"li"},"tap")," in our pipe to handle this and manually calling the ",(0,s.kt)("inlineCode",{parentName:"li"},"this.state.patch()")," method in our component. It is still not reactive.")),(0,s.kt)("h2",{id:"step-3-fully-reactive-component"},"Step 3. Fully reactive component."),(0,s.kt)("p",null,"Let's do another round and refactor the ",(0,s.kt)("inlineCode",{parentName:"p"},"List")," component using ",(0,s.kt)("inlineCode",{parentName:"p"},"@rx-angular/state"),". The core of it is operators ",(0,s.kt)("inlineCode",{parentName:"p"},"mergeAll()")," that works with a stream of streams instead of single values and ",(0,s.kt)("inlineCode",{parentName:"p"},"scan()")," that accumulates values from these streams into single state observable."),(0,s.kt)("p",null,"First step will be adding ",(0,s.kt)("inlineCode",{parentName:"p"},"RxState")," service to our component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  ...\n  providers: [RxState],\n  ...\n})\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(private api: TodoApiService, private state: RxState<IChecklist>)\n")),(0,s.kt)("p",null,"RxState service is in component providers. That means that the lifecycle of this service will be nearly the same as the lifecycle of the component. And on component destruction, service will also be destroyed. We can now entirely remove our ",(0,s.kt)("inlineCode",{parentName:"p"},"State")," class. Also, we can get rid of the ",(0,s.kt)("inlineCode",{parentName:"p"},"OnDestroy")," lifecycle hook since we don't need to manage subscriptions manually anymore."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Reading from state:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"name$ = this.state.select('name');\ntasks$ = this.state.select('tasks');\n")),(0,s.kt)("p",null,"Visually it looks the same but the select operator provides a lot more than just passing keys. You can read about it ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/rx-angular/rx-angular/blob/main/libs/state/docs/api/rx-state.md#select"},"here"),". Also selection will be shareReplayed, distincted and undefined values will be filtered out."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Updating state reactively")),(0,s.kt)("p",null,"Since in this example our api calls are main producers of our state we can connect them to state\nusing ",(0,s.kt)("inlineCode",{parentName:"p"},"connect")," method."),(0,s.kt)("p",null,"Let's start with initialization. Event ",(0,s.kt)("inlineCode",{parentName:"p"},"init$")," and trigger ",(0,s.kt)("inlineCode",{parentName:"p"},"@Input set id")," remains the same, but now we can remove the ",(0,s.kt)("inlineCode",{parentName:"p"},"tap")," operator from our ",(0,s.kt)("inlineCode",{parentName:"p"},"initHandler$")," and simply return raw data from our API."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"initHandler$ = this.init$.pipe(switchMap((id) => this.api.get(id)));\n")),(0,s.kt)("p",null,"Now ",(0,s.kt)("inlineCode",{parentName:"p"},"initHandler$")," is ",(0,s.kt)("inlineCode",{parentName:"p"},"Observable<IChecklist>"),". Let's connect it to state."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(private api: TodoApiService, private state: RxState<IChecklist>) {\n  this.state.connect(this.initHandler$);\n  ...\n}\n")),(0,s.kt)("p",null,"Cool, so now all values emitted by our ",(0,s.kt)("inlineCode",{parentName:"p"},"get()")," API call will be merged into the state. Subscription\nwill be managed automatically."),(0,s.kt)("p",null,"Now we need to update our ",(0,s.kt)("inlineCode",{parentName:"p"},"answerHandler$")," so it will return an id of task that was answered\n(api returns only status code). And connect it to our ",(0,s.kt)("inlineCode",{parentName:"p"},"tasks")," property."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"answerHandler$ = this.answer$.pipe(\n  switchMap((id) => this.api.answerTask(id).pipe(map(() => id)))\n);\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},'constructor(private api: TodoApiService, private state: RxState<IChecklist>) {\n  ...\n  this.state.connect("tasks", this.answerHandler$, (state, id) =>\n    state.tasks.filter(t => t.id !== id)\n  );\n}\n')),(0,s.kt)("p",null,"Note that we removed ",(0,s.kt)("inlineCode",{parentName:"p"},"withLatestFrom(this.tasks$)")," in favor of the ",(0,s.kt)("inlineCode",{parentName:"p"},"projectionFunction")," in ",(0,s.kt)("inlineCode",{parentName:"p"},"connect"),".\nFirst we define fields to be updated, then the source of the changes and lastly we provide the ",(0,s.kt)("inlineCode",{parentName:"p"},"projectionFunction"),". The functions' first first argument is the current state, the second is the change coming from\nour source. More on possible ",(0,s.kt)("inlineCode",{parentName:"p"},"connect")," variants ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/rx-angular/rx-angular/blob/main/libs/state/docs/api/rx-state.md#connect"},"here"),"."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Full component code")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export class ChecklistComponent {\n  @Input() set id(id: string) {\n    this.init$.next(id);\n  }\n\n  // READS\n  name$ = this.state.select('name');\n  tasks$ = this.state.select('tasks');\n\n  // EVENTS\n  init$ = new Subject<string>();\n  answer$ = new Subject<string>();\n\n  // HANDLERS\n  initHandler$ = this.init$.pipe(switchMap((id) => this.api.get(id)));\n  answerHandler$ = this.answer$.pipe(\n    switchMap((id) => this.api.answerTask(id).pipe(map(() => id)))\n  );\n\n  constructor(private api: TodoApiService, private state: RxState<IChecklist>) {\n    this.state.connect(this.initHandler$);\n    this.state.connect('tasks', this.answerHandler$, (state, id) =>\n      state.tasks.filter((t) => t.id !== id)\n    );\n  }\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Summary:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Both reading and writing are reactive."),(0,s.kt)("li",{parentName:"ul"},"No subscriptions. All managed automatically by package."),(0,s.kt)("li",{parentName:"ul"},"No lifecycle hooks."),(0,s.kt)("li",{parentName:"ul"},"Less code. No need to use tricky operators if you not sure how to use them. A massive chunk of a job done under the hood.")))}m.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,k=u["".concat(o,".").concat(m)]||u[m]||d[m]||s;return n?a.createElement(k,r(r({ref:t},c),{},{components:n})):a.createElement(k,r({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,r=new Array(s);r[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<s;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);