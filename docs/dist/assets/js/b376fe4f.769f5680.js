"use strict";(self.webpackChunkrx_angular=self.webpackChunkrx_angular||[]).push([[8043],{7603:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>c,toc:()=>u});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),s=["components"],l={sidebar_label:"Side Effects",title:"Handling Side Effects Reactively"},o="Handling Side Effects Reactively",c={unversionedId:"state/tutorials/basic-tutorial/side-effects",id:"state/tutorials/basic-tutorial/side-effects",title:"Handling Side Effects Reactively",description:"This section introduces and explores the concept of side effects and their reactive handling.",source:"@site/docs/state/tutorials/basic-tutorial/05-side-effects.md",sourceDirName:"state/tutorials/basic-tutorial",slug:"/state/tutorials/basic-tutorial/side-effects",permalink:"/docs/state/tutorials/basic-tutorial/side-effects",draft:!1,editUrl:"https://github.com/rx-angular/rx-angular/edit/main/docs/state/tutorials/basic-tutorial/05-side-effects.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_label:"Side Effects",title:"Handling Side Effects Reactively"},sidebar:"docs",previous:{title:"Global State",permalink:"/docs/state/tutorials/basic-tutorial/global-state"},next:{title:"Increment a Value",permalink:"/docs/state/tutorials/increment-a-value"}},p={},u=[{value:"Examples",id:"examples",level:2},{value:"Application",id:"application",level:2},{value:"Manage side effects",id:"manage-side-effects",level:2},{value:"Refactor the background-process side effect",id:"refactor-the-background-process-side-effect",level:2}],f={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"handling-side-effects-reactively"},"Handling Side Effects Reactively"),(0,i.kt)("p",null,"This section introduces and explores the concept of side effects and their reactive handling."),(0,i.kt)("p",null,"Before we get any further, let's define two terms, ",(0,i.kt)("em",{parentName:"p"},"side effect")," and ",(0,i.kt)("em",{parentName:"p"},"pure function"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Pure function:"),"\nA function is called pure if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Its return value is the same for the same arguments, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"function add(a, b) { return a + b}")),(0,i.kt)("li",{parentName:"ul"},"Its executed internal logic has no side effects")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Side Effect:"),"\nA function has a ",(0,i.kt)("em",{parentName:"p"},"side effect")," if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"There's a mutation of local static variables, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"this.prop = value")),(0,i.kt)("li",{parentName:"ul"},"Non-local variables are used")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Let's look at a couple of examples that will make the above definitions easier to understand."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"let state = true;\nsideEffectFn();\n\nfunction sideEffectFn() {\n  state = true;\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"mutable reference arguments get passed")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"let state = { isVisible: false };\nlet newState = sideEffectFn(state);\n\nfunction sideEffectFn(oldState) {\n  oldState.isVisible = true;\n  return oldState;\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"I/O is changed")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"let state = { isVisible: false };\nsideEffectFn(state);\n\nfunction sideEffectFn(state) {\n  console.log(state);\n  // or\n  this.render(state);\n}\n")),(0,i.kt)("p",null,"As a good rule of thumb, you can consider every function without a return value to be a side effect."),(0,i.kt)("p",null,"Yet, essentially, a side effect always has 2 important parts associated with it:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the trigger"),(0,i.kt)("li",{parentName:"ul"},"the side-effect logic")),(0,i.kt)("p",null,"In the above examples, the trigger was the method call itself. That is one way of doing it, but not the only one. We can also set a value emitted from an ",(0,i.kt)("inlineCode",{parentName:"p"},"Observable")," as a trigger.\nThus, you may use a render call or any other logic executed by the trigger as the side-effect logic."),(0,i.kt)("h2",{id:"application"},"Application"),(0,i.kt)("p",null,"With this in mind, let's take a look at the component logic and see if we can identify a side effect:"),(0,i.kt)("p",null,"First, we initialize a background process in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ngOnInit")," over ",(0,i.kt)("inlineCode",{parentName:"p"},"resetRefreshTick")," (see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rx-angular/rx-angular/tree/main/apps/demos/src/app/features/tutorials/basics/5-side-effects"},"side-effects.start.component.ts"),".)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"  ngOnInit(): void {\n    this.resetRefreshTick();\n  }\n")),(0,i.kt)("p",null,"The interval also gets reset whenever the input binding for ",(0,i.kt)("inlineCode",{parentName:"p"},"refreshInterval")," changes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"   @Input()\n    set refreshInterval(refreshInterval: number) {\n      if (refreshInterval > 4000) {\n        this.set({ refreshInterval });\n        this.resetRefreshTick()\n      }\n    }\n")),(0,i.kt)("p",null,"Another side effect is contained in the ",(0,i.kt)("inlineCode",{parentName:"p"},"onRefreshClicks")," callback. Here, we dispatch an action to the global store."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"  onRefreshClicks(event) {\n    this.listService.refetchList();\n  }\n")),(0,i.kt)("p",null,"Let's refactor those parts and handle them in a clean and reactive way."),(0,i.kt)("h1",{id:"refactor-to-a-reactive-ui"},"Refactor to a reactive UI"),(0,i.kt)("p",null,"As RxJS provides us with a very powerful way of composing emitted events, we will refactor our UI interaction with the streams."),(0,i.kt)("p",null,"UI interaction, in general, can come from buttons, inputs, forms, scroll or resize events, etc."),(0,i.kt)("p",null,"In our case, we have the refresh button as UI interaction. To get this interaction as an ",(0,i.kt)("inlineCode",{parentName:"p"},"Observable"),", we create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Subject")," in the component class and fire its ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," method on every button click."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<button mat-raised-button color="primary" (click)="refreshClicks.next($event)">\n  Refresh List\n</button>\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"export class SideEffectsStart\n  extends RxState<ComponentState>\n  implements OnInit, OnDestroy\n{\n  refreshClicks$ = new Subject<Event>();\n  //...\n}\n")),(0,i.kt)("p",null,"This is the trigger for our side effect."),(0,i.kt)("h2",{id:"manage-side-effects"},"Manage side effects"),(0,i.kt)("p",null,"To maintain side effects RxAngular provides a deprecated method ",(0,i.kt)("inlineCode",{parentName:"p"},"RxState#hold"),".\nAs this method will get removed in the future we directly focus on the new method and use ",(0,i.kt)("inlineCode",{parentName:"p"},"RxEffects#register"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"RxEffects")," is used in the same way as ",(0,i.kt)("inlineCode",{parentName:"p"},"RxState"),' as "component only provider". This means we need to add it to the components ',(0,i.kt)("inlineCode",{parentName:"p"},"providers")," array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Component({\n  ...\n  providers: [\n    RxEffects\n  ]\n})\nexport class SideEffectsStart extends RxState<ComponentState> {\n constructor(private rxEffects: RxEffects) {\n\n }\n}\n")),(0,i.kt)("p",null,"From the ",(0,i.kt)("inlineCode",{parentName:"p"},"resetRefreshTick")," method, we now move the logic that starts the tick and place it in the ",(0,i.kt)("inlineCode",{parentName:"p"},"register")," method of ",(0,i.kt)("inlineCode",{parentName:"p"},"RxEffects")," as a callback parameter."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"register")," method's job, as the name implies, is to ",(0,i.kt)("em",{parentName:"p"},"registers/holds")," something. Namely, it holds a subscription to a side effect and takes care of its initialization.\nFurthermore, it automatically handles the subscription management and unsubscribes if the component gets destroyed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"constructor(...) {\n  this.rxEffects.register(this.refreshClicks$, () => this.listService.refetchList());\n}\n")),(0,i.kt)("p",null,"With this implementation, we should be able to dispatch an action on every button click."),(0,i.kt)("p",null,"Optionally, we could also put the side effect into a tap operator. To that end, we create a new property in our class called ",(0,i.kt)("inlineCode",{parentName:"p"},"refreshListSideEffect$")," and assign the newly created click ",(0,i.kt)("inlineCode",{parentName:"p"},"Observable")," to it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"refreshListSideEffect$ = this.refreshClicks$.pipe(\n  tap(() => this.listService.refetchList())\n);\n")),(0,i.kt)("p",null,"and then register it directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"constructor(...) {\n  this.rxEffects.register(refreshListSideEffect$);\n}\n")),(0,i.kt)("h2",{id:"refactor-the-background-process-side-effect"},"Refactor the background-process side effect"),(0,i.kt)("p",null,"Another side effect in this component is the background process that dispatches the refresh action in an interval defined over the ",(0,i.kt)("inlineCode",{parentName:"p"},"refreshInterval")," input binding."),(0,i.kt)("p",null,"If we take a look at the current implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"resetRefreshTick"),", we will see 2 pieces:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"One piece is responsible for deriving an interval from the current ",(0,i.kt)("inlineCode",{parentName:"li"},"refreshInterval")," value in milliseconds."),(0,i.kt)("li",{parentName:"ul"},"The other piece fires the actual side effect.")),(0,i.kt)("p",null,"Let's first refactor the trigger ",(0,i.kt)("inlineCode",{parentName:"p"},"this.select('refreshInterval').pipe(switchMap(ms => timer(0, ms)))")," to a separate class property."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"intervalRefreshTick$ = this.select(\n  map((s) => s.refreshInterval),\n  switchMap((ms) => timer(0, ms))\n);\n")),(0,i.kt)("p",null,"If we think about it, both the button click and interval are triggers for the same side effect.\nBesides, their emitted value is irrelevant for the side effect and only serves as a trigger for its execution."),(0,i.kt)("p",null,"This means we can simply merge their outputs together."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"refreshListSideEffect$ = merge(\n  this.refreshClicks,\n  this.intervalRefreshTick$\n).pipe(tap((_) => this.listService.refetchList()));\n")),(0,i.kt)("p",null,"As a last step, we could use another overload of the ",(0,i.kt)("inlineCode",{parentName:"p"},"register")," method to get better readability of the code."),(0,i.kt)("p",null,"The second overload of the ",(0,i.kt)("inlineCode",{parentName:"p"},"register")," method takes a trigger ",(0,i.kt)("inlineCode",{parentName:"p"},"Observable")," and a separate function that is executed whenever the trigger fires.\nIt generally looks like this:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"register(o$: Observable<T>, sideEffect: (v: T) => void)")),(0,i.kt)("p",null,"In our constructor, we can use it as following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"constructor(...) {\n  // ...\n  this.rxEffects.register(refreshListSideEffect$, () => this.listService.refetchList());\n}\n")),(0,i.kt)("p",null,"Now, it's time to reap the benefits!"),(0,i.kt)("p",null,"Let's delete code."),(0,i.kt)("p",null,"In the example, we can get rid of the following snippets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"  implements OnInit, OnDestroy\n  // ..\n  intervalSubscription = new Subscription();\n  // ...\n  ngOnDestroy(): void {\n    this.intervalSubscription.unsubscribe();\n  }\n  // ...\n  ngOnInit(): void {\n    this.resetRefreshTick();\n  }\n  // ...\n  resetRefreshTick() {\n    this.intervalSubscription.unsubscribe();\n    this.intervalSubscription = this.select('refreshInterval')\n      .pipe(\n        switchMap(ms => interval(ms)),\n        tap(_ => this.listService.refetchList())\n      )\n      .subscribe();\n  }\n  // ...\n  onRefreshClicks(event) {\n    this.listService.refetchList();\n  }\n  // ...\n}\n")),(0,i.kt)("p",null,"We can say without any doubt we did an excellent job. :)"),(0,i.kt)("p",null,"Side effects are now organized in a structured and readable way, and the subscription handling gets done automatically by the state layer.\nFurthermore, we managed to get rid of all implemented lifecycles as well as the callback function for the button click."),(0,i.kt)("p",null,"All in all, an amazing job!"))}d.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),f=c(n),d=r,h=f["".concat(o,".").concat(d)]||f[d]||u[d]||i;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=f;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"}}]);